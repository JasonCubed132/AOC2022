use crate::utils::solver_types::{solve_linear, SolutionLinear};
use anyhow::{anyhow, Result};
use itertools::Itertools;
use std::collections::HashSet;

pub struct Day9Solution {}

pub fn day09(input: &str) -> Result<f32> {
    solve_linear::<Day9Solution, _, _, _>(input)
}

#[derive(Debug, Clone)]
pub enum Direction {
    Up(usize),
    Down(usize),
    Left(usize),
    Right(usize),
}

impl Direction {
    fn make(input: &str, num: usize) -> Direction {
        match input {
            "U" => Direction::Up(num),
            "D" => Direction::Down(num),
            "L" => Direction::Left(num),
            "R" => Direction::Right(num),
            _ => panic!(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
struct Point {
    x: i32,
    y: i32,
}

fn propegate_rope(rope: &mut Vec<Point>) {
    for i in 1..rope.len() {
        if (rope[i].y - rope[i - 1].y).pow(2) + (rope[i].x - rope[i - 1].x).pow(2) > 2 {
            if rope[i].y > rope[i - 1].y {
                rope[i].y -= 1;
            } else if rope[i].y < rope[i - 1].y {
                rope[i].y += 1;
            }

            if rope[i].x > rope[i - 1].x {
                rope[i].x -= 1;
            } else if rope[i].x < rope[i - 1].x {
                rope[i].x += 1;
            }
        }
    }
}

fn simulate(input: Vec<Direction>, rope_length: usize) -> i32 {
    let mut rope = vec![Point { x: 0, y: 0 }; rope_length];

    let mut set: HashSet<Point> = HashSet::new();
    set.insert(rope[rope.len() - 1].clone());

    for mov in input {
        match mov {
            Direction::Up(num) => {
                let count = num;

                for _ in 0..count {
                    rope[0].y -= 1;

                    propegate_rope(&mut rope);

                    set.insert(rope[rope.len() - 1].clone());
                }
            }
            Direction::Down(num) => {
                let count = num;

                for _ in 0..count {
                    rope[0].y += 1;

                    propegate_rope(&mut rope);

                    set.insert(rope[rope.len() - 1].clone());
                }
            }
            Direction::Left(num) => {
                let count = num;

                for _ in 0..count {
                    rope[0].x -= 1;

                    propegate_rope(&mut rope);

                    set.insert(rope[rope.len() - 1].clone());
                }
            }
            Direction::Right(num) => {
                let count = num;

                for _ in 0..count {
                    rope[0].x += 1;

                    propegate_rope(&mut rope);

                    set.insert(rope[rope.len() - 1].clone());
                }
            }
        }
    }

    let result: i32 = set.len().try_into().unwrap();

    result
}

impl SolutionLinear<Vec<Direction>, i32, i32> for Day9Solution {
    fn load(input: &str) -> Result<Vec<Direction>> {
        Ok(input
            .lines()
            .map(|x| {
                let parts = x.split(" ").collect_vec();
                let num = parts[1].parse::<usize>();
                Direction::make(parts[0], num.unwrap())
            })
            .collect_vec())
    }

    fn part1(input: &mut Vec<Direction>) -> Result<i32> {
        let result = simulate(input.to_vec(), 2);
        Ok(result)
    }

    fn part2(input: &mut Vec<Direction>, _part_1_solution: i32) -> Result<i32> {
        let result = simulate(input.to_vec(), 10);
        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::Day9Solution;
    use crate::utils::solver_types::SolutionLinear;
    use rstest::rstest;

    #[rstest]
    #[case(
        "R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2",
        13,
        1
    )]
    #[case(
        "R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20",
        88,
        36
    )]
    fn validate_linear(#[case] input: &str, #[case] expected_1: i32, #[case] expected_2: i32) {
        let mut input = Day9Solution::load(input).unwrap();
        let p1 = Day9Solution::part1(&mut input).unwrap();
        let p2 = Day9Solution::part2(&mut input, p1).unwrap();

        assert_eq!(expected_1, p1);
        assert_eq!(expected_2, p2);
    }
}

/*
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........54321H.........
..........................
..........................
..........................
..........................
..........................

..........................
..........................
..........................
..........................
..........................
..........................
................H.........
...........54321..........
..........................
..........................
..........................
..........................
..........................

..........................
..........................
..........................
..........................
..........................
................H.........
...............1..........
...........5432...........
..........................
..........................
..........................
..........................
..........................

..........................
..........................
..........................
..........................
................H.........
...............1..........
..............2...........
...........543............
..........................
..........................
..........................
..........................
..........................

..........................
..........................
..........................
................H.........
...............1..........
..............2...........
.............3............
...........54.............
..........................
..........................
..........................
..........................
..........................

.......................... 5
..........................
..........................
................H.........
...............1..........
..............2...........
.............3............
............4.............
...........5..............
..........................
..........................
..........................
..........................
..........................

.......................... 6
..........................
................H.........
................1.........
...............2..........
..............3...........
.............4............
............5.............
...........6..............
..........................
..........................
..........................
..........................
..........................

.......................... 7
................H.........
................1.........
................2.........
...............3..........
..............4...........
.............5............
............6.............
...........7..............
..........................
..........................
..........................
..........................
..........................

................H......... 8
................1.........
................2.........
................3.........
...............4..........
..............5...........
.............6............
............7.............
...........8..............
..........................
..........................
..........................
..........................
..........................
*/

/*
......
......
......
....H.
4321..

......
......
....H.
......
4321..

......
......
....H.
....1.
432...

......
......
....H.
...21.
43....

......
......
....H.
..321.
4.....

......
......
....H.
.4321.
5.....
*/
